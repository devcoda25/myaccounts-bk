generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User Core
model User {
  id                String    @id @default(uuid())
  email             String    @unique
  firstName         String?
  otherNames        String?
  inviteCode        String?
  phoneNumber       String?
  passwordHash      String?
  
  // Profile
  dob               DateTime?
  country           String?
  avatarUrl         String?

  emailVerified     Boolean   @default(false)
  phoneVerified     Boolean   @default(false)
  twoFactorEnabled  Boolean   @default(false)
  twoFactorSecret   String?   // Encrypted TOTP secret
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  credentials       UserCredential[]
  memberships       UserOrganization[]
  sessions          Session[]
  wallet            Wallet?
  auditLogs         AuditLog[]
  paymentMethods    PaymentMethod[]
  kyc               Kycrecord?
  consents          OAuthConsent[]

  @@map("users")
}

// Multi-Authentication Methods (Social, Enterprise, etc.)
model UserCredential {
  id           String   @id @default(uuid())
  userId       String
  providerType String   // "password", "google", "saml"
  providerId   String   // external ID or same as email for password
  secretHash   String?  // password hash or token
  metadata     Json?    // e.g., profile data from provider

  user         User     @relation(fields: [userId], references: [id])

  @@unique([providerType, providerId])
  @@map("user_credentials")
}

// Organizations (Tenants)
model Organization {
  id          String   @id @default(uuid())
  name        String
  domain      String?  @unique // for formatting business emails or federation
  type        String   // "enterprise", "provider", "individual"
  metadata    Json?    // SAML config, branding, etc.

  members     UserOrganization[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("organizations")
}

// Membership (Users <-> Orgs)
model UserOrganization {
  userId      String
  orgId       String
  role        String   // "admin", "member", "owner" (can be normalized to role table later)
  joinedAt    DateTime @default(now())

  user        User         @relation(fields: [userId], references: [id])
  organization Organization @relation(fields: [orgId], references: [id])

  @@id([userId, orgId])
  @@map("user_organizations")
}

// OIDC Clients (EVzone Services)
model OAuthClient {
  id                String   @id @default(uuid()) // client_id
  clientId          String   @unique
  clientSecretHash  String?  // for confidential clients
  name              String
  redirectUris      String[] 
  grantTypes        String[] // "authorization_code", "refresh_token"
  isPublic          Boolean  @default(false)
  isFirstParty      Boolean  @default(true) // skip consent if true
  
  sessions          Session[]
  consents          OAuthConsent[]

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@map("oauth_clients")
}

// Sessions & Refresh Tokens
model Session {
  id                String   @id @default(uuid())
  userId            String
  clientId          String?
  refreshTokenHash  String?  @unique
  expiresAt         DateTime
  deviceInfo        Json?    // IP, UserAgent
  
  user              User        @relation(fields: [userId], references: [id])
  client            OAuthClient? @relation(fields: [clientId], references: [id])

  createdAt         DateTime @default(now())
  lastUsedAt        DateTime @default(now())

  @@map("sessions")
}

model AuthCode {
  code        String   @id @unique
  clientId    String
  userId      String
  redirectUri String
  codeChallenge String
  codeChallengeMethod String @default("S256")
  expiresAt   DateTime
  used        Boolean  @default(false)

  createdAt   DateTime @default(now())

  @@map("auth_codes")
}

model VerificationRequest {
  id          String   @id @default(uuid())
  identifier  String   // email or phone
  token       String   // OTP or hash
  type        String   // "EMAIL_VERIFY", "PASSWORD_RESET"
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  @@unique([identifier, type, token])
  @@map("verification_requests")
}

// -----------------------------------------------------------------------------
// Wallet Module
// -----------------------------------------------------------------------------

model Wallet {
  id          String   @id @default(uuid())
  userId      String   @unique // One wallet per user for MVP
  currency    String   @default("USD")
  balance     Decimal  @default(0.00) @db.Decimal(15, 2)
  status      String   @default("active") // active, frozen
  
  user        User     @relation(fields: [userId], references: [id])
  transactions Transaction[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("wallets")
}

model Transaction {
  id            String   @id @default(uuid())
  walletId      String
  amount        Decimal  @db.Decimal(15, 2)
  currency      String
  type          String   // "deposit", "withdrawal", "payment", "refund"
  status        String   // "pending", "completed", "failed"
  referenceId   String?  // External Order ID or Payment Gateway ID
  description   String?
  
  wallet        Wallet   @relation(fields: [walletId], references: [id])

  // New fields for frontend alignment
  providerRef   String?
  counterparty  String?
  channel       String?  @default("Wallet") // Wallet, Charging, Marketplace, etc.
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt // Added updatedAt

  @@map("wallet_transactions")
}

model PaymentMethod {
  id          String   @id @default(uuid())
  userId      String
  type        String   // "card", "mobile_money"
  provider    String   // "stripe", "mtn"
  token       String   // Gateway token (PCI safe)
  details     Json?    // last4, brand, etc.
  isDefault   Boolean  @default(false)

  user        User     @relation(fields: [userId], references: [id])

  createdAt   DateTime @default(now())

  @@map("payment_methods")
}

// -----------------------------------------------------------------------------
// Compliance & Audit
// -----------------------------------------------------------------------------

model Kycrecord {
  id             String   @id @default(uuid())
  userId         String   @unique
  status         String   // "pending", "verified", "rejected"
  level          Int      @default(1)
  documentsRegex Json?    // References to stored docs
  notes          String?
  
  user           User     @relation(fields: [userId], references: [id])

  submittedAt    DateTime @default(now())
  verifiedAt     DateTime?

  @@map("kyc_records")
}

model OAuthConsent {
  userId      String
  clientId    String
  scopes      String[]
  grantedAt   DateTime @default(now())

  user        User        @relation(fields: [userId], references: [id])
  client      OAuthClient @relation(fields: [clientId], references: [id])

  @@id([userId, clientId])
  @@map("oauth_consents")
}

model AuditLog {
  id        String   @id @default(uuid())
  userId    String?
  action    String   // "login", "password_change", "wallet_deposit"
  details   Json?
  ipAddress String?
  
  user      User?    @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())

  @@map("audit_logs")
}
